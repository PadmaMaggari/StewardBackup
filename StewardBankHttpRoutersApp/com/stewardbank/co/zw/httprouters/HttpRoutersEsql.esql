
/*
Author: Mir Mohsin Ali/Rathod Veerender
Version:0.0.1
Date of Creation:08-04-2020
Date of Modification:06-04-2020,08-06-2020,12-06-2020 (We will get the queue details from DB based on Processing code,channel,message domain and those details will be stored in Cache).
Description: This is the HTTP router flow.It will route the message to actual transaction flow based on Processing Code,channel and message domain.
This HTTP Router would be triggered whenever Frontend initiates the request to ESB.
*/
BROKER SCHEMA com.stewardbank.co.zw.httprouters
PATH com.stewardbank.co.zw.common.esql;
DECLARE getDBDetailsCache SHARED ROW;
DECLARE esbPcode SHARED ROW;
DECLARE LOG_CONFIG_PATH EXTERNAL CHARACTER '';
DECLARE IsLogRequired EXTERNAL CHARACTER '';
DECLARE RAW_AUDIT_Q EXTERNAL CHARACTER '';
DECLARE ERR_AUDIT_Q EXTERNAL CHARACTER '';
DECLARE EXCEPTION_Q EXTERNAL CHARACTER '';
DECLARE LOG4J_INIT_ERROR_MSG EXTERNAL CHARACTER '';
DECLARE DSN EXTERNAL CHARACTER '';
DECLARE HTTP_FLOW_TABLE EXTERNAL CHARACTER '';
CREATE COMPUTE MODULE HttpRequestRouterFlow_RouteToInterfaceBasedOnProcessingCode
	DECLARE rc BOOLEAN;
	CREATE FUNCTION Main() RETURNS BOOLEAN
	BEGIN
		CALL RouteToInterfaceBasedOnProcessingCode();
		RETURN FALSE;
	END;

	CREATE PROCEDURE RouteToInterfaceBasedOnProcessingCode() BEGIN
		DECLARE inRef REFERENCE TO InputRoot;
		DECLARE procCodeData,QueueName,channel CHARACTER '';
		DECLARE qDetails ROW;
		DECLARE outRefer REFERENCE TO OutputRoot;
		DECLARE ccidRef INTEGER InputRoot.Properties.CodedCharSetId;
		DECLARE encodeRef INTEGER InputRoot.Properties.Encoding;
		SET Environment.MQRFH2.RequestIdentifier = InputLocalEnvironment.Destination.HTTP.RequestIdentifier;
		SET Environment.MQRFH2.usr = InputRoot.HTTPInputHeader;
		SET Environment.MQRFH2.usr.dbLogTime = CAST(CURRENT_TIME AS CHAR FORMAT 'HHmmss');
		SET Environment.MQRFH2.usr.dbLogDate = CAST(CURRENT_DATE AS CHAR FORMAT 'ddMM');
		SET Environment.Variables.messageID = CAST(Environment.MQRFH2.RequestIdentifier AS CHAR);
		SET Environment.Variables.reqMsg = CAST(InputRoot.JSON AS CHAR CCSID ccidRef);
		DECLARE procCode CHARACTER InputRoot.JSON.Data.processingCode;
		IF (InputRoot.JSON.Data.processingCode IS NOT NULL) OR
			(InputRoot.JSON.Data.processingCode <> '') OR
			(InputRoot.JSON.Data.header.processingCode IS NOT NULL) OR
			(InputRoot.JSON.Data.header.processingCode <> '') THEN
			SET Environment.Variables.processingCode = COALESCE(InputRoot.JSON.Data.processingCode,InputRoot.JSON.Data.header.processingCode,'');
			Set Environment.MQRFH2.usr.sbPcode = Environment.Variables.processingCode;
		END IF;
		IF (InputRoot.JSON.Data.channel IS NOT NULL) OR
			(InputRoot.JSON.Data.channel <> '') OR
			(InputRoot.JSON.Data.header.channel IS NOT NULL) OR
			(InputRoot.JSON.Data.header.channel <> '') THEN
			SET Environment.Variables.channel = COALESCE(InputRoot.JSON.Data.channel,InputRoot.JSON.Data.header.channel,'');
		END IF;
		DECLARE domainDataRef REFERENCE TO InputRoot.JSON.Data;
		DECLARE domainName CHARACTER FIELDNAME(InputBody);
		SET Environment.Variables.reqMsg = getPayLoad(domainName,domainDataRef,encodeRef,ccidRef);
		CALL initLog4j(LOG_CONFIG_PATH) INTO rc;
		IF ( rc = FALSE ) THEN
			SET Environment.Variables.Log4j.ErrorMsg = LOG4J_INIT_ERROR_MSG;
		END IF;
		IF IsLogRequired LIKE 'Y' THEN
			CALL writeToLogFile(MessageFlowLabel,'HTTPLogger','DEBUG','=============HTTP Incoming Router Start ==============') INTO rc ;
			CALL writeToLogFile(MessageFlowLabel,'HTTPLogger','DEBUG','JSON Request: '|| Environment.Variables.reqMsg) INTO rc ;
			----------DBLogging LOGGING -------------------
			CALL DBLogging(Environment.Variables.messageID,Environment.Variables.reqMsg,'HTTPRouter Request',ApplicationLabel,BrokerName,Environment.MQRFH2.usr.dbLogTime,Environment.MQRFH2.usr.dbLogDate,'',outRefer);
			SET OutputLocalEnvironment.Destination.MQ.DestinationData[1].queueName = RAW_AUDIT_Q;
			PROPAGATE TO TERMINAL 'out';
			----------------------------------
		END IF;
		IF (FIELDNAME(Environment.Variables.processingCode) IS NULL) AND (FIELDNAME(Environment.Variables.channel) IS NULL) THEN
			CALL errorResponse('no key[proccessingCode & Channel] in the request','ESB_006');
			RETURN;
		ELSEIF (FIELDVALUE(Environment.Variables.processingCode) = '' AND FIELDVALUE(Environment.Variables.channel) = '') THEN
			CALL errorResponse('channel & processingCode  must be specified','ESB_007');
			RETURN;
		ELSEIF FIELDNAME(Environment.Variables.channel) IS NULL THEN
			CALL errorResponse('no key[channel] in the request','ESB_008');
			RETURN;
		ELSEIF FIELDVALUE(Environment.Variables.channel) = '' THEN
			CALL errorResponse('channel name must be specified','ESB_009');
			RETURN;
		ELSEIF FIELDNAME(Environment.Variables.processingCode) IS NULL THEN
			CALL errorResponse('no key[proccessingCode] in the request','ESB_010');
			RETURN;
		ELSEIF FIELDVALUE(Environment.Variables.processingCode) = '' THEN
			CALL errorResponse('proccessingCode must be specified','ESB_011');
			RETURN;
		ELSEIF NOT LENGTH(FIELDVALUE(Environment.Variables.processingCode)) = 6 THEN
			CALL errorResponse('processing code length must be = 6','ESB_012');
			RETURN;
		ELSE
			SET procCodeData = SUBSTRING(Environment.Variables.processingCode FROM 1 FOR 2);
			SET channel = Environment.Variables.channel;
		END IF;

		IF EXISTS(getDBDetailsCache.Values[]) THEN
			CALL writeToLogFile(MessageFlowLabel,'HTTPLogger','DEBUG','Values available in shared cache: '|| getDBDetailsCache.Values.*[])INTO rc;
			SET qDetails.values[] = SELECT P.HTTP_REQ, P.HTTP_RES, P.MSGDOMAIN FROM getDBDetailsCache.Values[] AS P WHERE P.PROC_CODE = procCodeData AND P.CHANNEL = channel;
			IF EXISTS(qDetails.values[]) THEN
				IF FIELDVALUE(qDetails.values.MSGDOMAIN) IS NOT NULL AND FIELDVALUE(qDetails.values.HTTP_REQ) IS NOT NULL THEN
					SET QueueName = qDetails.values.HTTP_REQ;
					CALL generateEsbPcode(Environment.Variables.processingCode,Environment.Variables.channel);
				ELSEIF FIELDVALUE(qDetails.values.HTTP_REQ) IS NULL THEN
					CALL errorResponse('No Queues based on processingCode or Channel Name','ESB_005');
					RETURN;
				ELSEIF FIELDVALUE(qDetails.values.MSGDOMAIN) IS NULL THEN
					CALL errorResponse('No Domain based on processingCode or Channel Name','ESB_04');
					RETURN;
				ELSE
					CALL errorResponse('No Domain and Queues based on processingCode or Channel Name','ESB_003');
					RETURN;
				END IF;
			ELSE
				CALL errorResponse('Invalid processingCode or Channel Name','ESB_002');
				RETURN;
			END IF;
		ELSE
			CALL writeToLogFile(MessageFlowLabel,'HTTPLogger','DEBUG','Calling the Cache')INTO rc;
			CALL STORE_CACHE();
			SET qDetails.values[] = SELECT P.HTTP_REQ, P.HTTP_RES, P.MSGDOMAIN FROM getDBDetailsCache.Values[] AS P WHERE P.PROC_CODE = procCodeData AND P.CHANNEL = channel;
			IF EXISTS(qDetails.values[]) THEN
				IF FIELDVALUE(qDetails.values.MSGDOMAIN) IS NOT NULL AND FIELDVALUE(qDetails.values.HTTP_REQ) IS NOT NULL THEN
					SET QueueName = qDetails.values.HTTP_REQ;
					CALL generateEsbPcode(Environment.Variables.processingCode,Environment.Variables.channel);
				ELSEIF FIELDVALUE(qDetails.values.HTTP_REQ) IS NULL THEN
					CALL errorResponse('No Queues based on processingCode or Channel Name','ESB_005');
					RETURN;
				ELSEIF FIELDVALUE(qDetails.values.MSGDOMAIN) IS NULL THEN
					CALL errorResponse('No Domain based on processingCode or Channel Name','ESB_04');
					RETURN;
				ELSE
					CALL errorResponse('No Domain and Queues based on processingCode or Channel Name','ESB_003');
					RETURN;
				END IF;
			ELSE
				CALL errorResponse('Invalid processingCode or Channel Name','ESB_002');
				RETURN;
			END IF;
		END IF;
		SET Environment.MQRFH2.usr.resQueueName = qDetails.values.HTTP_RES;
		SET OutputRoot.Properties = InputRoot.Properties;
		SET OutputRoot.MQRFH2 = Environment.MQRFH2;
		SET OutputRoot.JSON.Data = InputRoot.JSON.Data;
		CALL writeToLogFile(MessageFlowLabel,'HTTPLogger','DEBUG','=============Business QUEUENAME=============='' '||QueueName||'') INTO rc ;
		SET OutputLocalEnvironment.Destination.MQ.DestinationData[1].queueName = QueueName;
		CALL writeToLogFile(MessageFlowLabel,'HTTPLogger','DEBUG','=============HTTP Incoming Router End ==============') INTO rc ;
		PROPAGATE TO TERMINAL 'out';
	END;
	/*Retrieve application related queues from database or cache*/
	CREATE PROCEDURE STORE_CACHE ()
	BEGIN
		SET getDBDetailsCache.Values[] = SELECT A.PROC_CODE, A.HTTP_REQ, A.HTTP_RES, A.CHANNEL, A.MSGDOMAIN FROM Database.INTEGRATION_SOL_DETAILS AS A WHERE A.MSGDOMAIN = 'JSON';
		IF EXISTS(getDBDetailsCache.Values[]) OR getDBDetailsCache <> '' OR getDBDetailsCache IS NOT NULL THEN
			CALL writeToLogFile(MessageFlowLabel,'Log','DEBUG','Retrieved values from Database')INTO rc;
		ELSE
			CALL errorResponse('No data based on domain name JSON','ESB_001');
			CALL writeToLogFile(MessageFlowLabel,'Log','DEBUG','No Data retrieved from Database')INTO rc;
			RETURN;
		END IF;
	END;
	CREATE PROCEDURE errorResponse (IN msg CHAR,IN errorCode CHAR)
	BEGIN
		CREATE LASTCHILD OF OutputRoot DOMAIN 'JSON';
		CREATE LASTCHILD OF OutputRoot.JSON NAME 'Data';
		DECLARE outJsonRef REFERENCE TO OutputRoot.JSON.Data;
		SET outJsonRef.statusCode = '000';
		SET outJsonRef.status = 'FAILED';
		SET outJsonRef.message = msg;
		SET outJsonRef.responseBody.source = 'ESB';
		SET outJsonRef.responseBody.applicationName = ApplicationLabel;
		SET outJsonRef.responseBody.applicationErrorCode = errorCode;
		SET Environment.Variables.jsonData = OutputRoot.JSON;
		SET OutputLocalEnvironment.Destination.HTTP.RequestIdentifier = CAST(Environment.MQRFH2.RequestIdentifier AS BLOB);
		PROPAGATE TO TERMINAL 'out1';
	END;
	
	
	CREATE PROCEDURE generateEsbPcode(IN pcode CHARACTER,IN channel CHARACTER)
	BEGIN
			/*get esb processing codes from cache if available else call database to retrive values */
			IF EXISTS(esbPcode.val[]) THEN 
				CALL writeToLogFile(MessageFlowLabel,'TCPRouterLog','DEBUG','===esb pcode values available in shared cache===')INTO rc;	
				CALL filterPcode(pcode,channel);
			ELSE
				CALL writeToLogFile(MessageFlowLabel,'TCPRouterLog','DEBUG','===esb pcode values not available in shared cache calling db===')INTO rc;
				CALL getEsbPcode(pcode,channel);
				CALL filterPcode(pcode,channel);
			END IF;
	END;
	/*get esb processing code by filter processing code based on channel and postilion processing code */
	CREATE PROCEDURE filterPcode(IN pcode CHARACTER,IN channel CHARACTER)
	BEGIN
			SET Environment.Variables.esbPcode.values[] = esbPcode.val[];
			FOR pcodeRef AS Environment.Variables.esbPcode.values[] DO
				IF (CONTAINS(channel,pcodeRef.CHANNEL) OR CONTAINS(channel,pcodeRef.CHANNEL2)
					OR CONTAINS(channel,pcodeRef.CHANNEL3) OR CONTAINS(channel,pcodeRef.CHANNEL4)) AND pcodeRef.POSTILION_PCODE = pcode THEN
						SET Environment.MQRFH2.usr.esbPcode = pcodeRef.ESB_PCODE;
						CALL writeToLogFile(MessageFlowLabel,'TCPRouterLog','DEBUG','====filtering done successfully====')INTO rc;
						CALL writeToLogFile(MessageFlowLabel,'TCPRouterLog','DEBUG','====ESB processing code===')INTO rc;
						CALL writeToLogFile(MessageFlowLabel,'TCPRouterLog','DEBUG',CAST(Environment.MQRFH2.usr.esbPcode AS CHARACTER))INTO rc;
				END IF;
			END FOR;
	END;
	/* get esb processing codes from database and store it in shared variable */
	CREATE PROCEDURE getEsbPcode(IN pcode CHARACTER,IN channel CHARACTER) 
	BEGIN
		IF pcode <> '' AND pcode IS NOT NULL THEN 
			IF channel <> '' AND channel IS NOT NULL THEN 
				SET esbPcode.val[] = SELECT A.* FROM Database.SB_ESB_PCODE AS A;
				IF EXISTS(esbPcode.val[]) THEN
						CALL writeToLogFile(MessageFlowLabel,'TCPRouterLog','DEBUG','Retrieved pcode values from Database')INTO rc;
				ELSE
					CALL writeToLogFile(MessageFlowLabel,'TCPRouterLog','DEBUG','No pcode retrieved from Database')INTO rc;
				END IF;
			ELSE
				CALL writeToLogFile(MessageFlowLabel,'TCPRouterLog','DEBUG','channel is null or empty')INTO rc;
			END IF;
		ELSE
			CALL writeToLogFile(MessageFlowLabel,'TCPRouterLog','DEBUG','processing code is null or empty')INTO rc;
		END IF;
	END;
	
END MODULE;
/*Generate json formated message and send to front end system*/
CREATE COMPUTE MODULE HttpResponseRouterFlow_GenerateResToFrontEnd
	DECLARE rc BOOLEAN;
	CREATE FUNCTION Main() RETURNS BOOLEAN
	BEGIN
		CALL GenerateResToFrontEnd();
		RETURN TRUE;
	END;

	CREATE PROCEDURE GenerateResToFrontEnd() BEGIN
		DECLARE rc BOOLEAN;
		DECLARE inRef REFERENCE TO InputRoot;
		SET Environment.MQRFH2 = InputRoot.MQRFH2;
		DECLARE procCodeData,QueueName CHARACTER '';
		DECLARE outRefer REFERENCE TO OutputRoot;
		DECLARE ccidRef INTEGER InputRoot.Properties.CodedCharSetId;
		DECLARE encodeRef INTEGER InputRoot.Properties.Encoding;
		DECLARE domainDataRef REFERENCE TO InputRoot.JSON.Data;
		SET Environment.Variables.msgID = CAST(Environment.MQRFH2.RequestIdentifier AS CHARACTER );
		SET Environment.Variables.reqMsg = getPayLoad(FIELDNAME(InputBody),domainDataRef,encodeRef,ccidRef);
		CALL initLog4j(LOG_CONFIG_PATH) INTO rc;
		IF ( rc = FALSE ) THEN
			SET Environment.Variables.Log4j.ErrorMsg = LOG4J_INIT_ERROR_MSG;
		END IF;
		IF IsLogRequired LIKE 'Y' THEN
			CALL writeToLogFile(MessageFlowLabel,'HTTPLogger','DEBUG','=============HTTP Outgoing Router Start ==============') INTO rc ;
			CALL writeToLogFile(MessageFlowLabel,'HTTPLogger','DEBUG','JSON Response: '|| Environment.Variables.reqMsg) INTO rc ;
			----------- DBLogging Properties ==============
			CALL DBLogging(Environment.Variables.msgID,Environment.Variables.reqMsg,'HTTPRouter Response',ApplicationLabel,BrokerName,Environment.MQRFH2.usr.dbLogTime,Environment.MQRFH2.usr.dbLogDate,'',outRefer);
			SET OutputLocalEnvironment.Destination.MQ.DestinationData[1].queueName = RAW_AUDIT_Q;
			PROPAGATE TO TERMINAL 'out1';
			------------------------------
		END IF;
		SET OutputRoot.Properties = InputRoot.Properties;
		SET OutputRoot.JSON.Data = InputRoot.JSON.Data;
		IF IsLogRequired LIKE 'Y' THEN
			CALL writeToLogFile(MessageFlowLabel,'HTTPLogger','DEBUG','======HTTP RequestIdentifier====='|| CAST(Environment.MQRFH2.RequestIdentifier AS CHARACTER)) INTO rc ;
		END IF;
		SET OutputLocalEnvironment.Destination.HTTP.RequestIdentifier = CAST(Environment.MQRFH2.RequestIdentifier AS BLOB);
		CALL writeToLogFile(MessageFlowLabel,'HTTPLogger','DEBUG','=============HTTP Outgoing Router End ==============') INTO rc ;
	END;
END MODULE;


CREATE COMPUTE MODULE HttpRequestRouterFlow_BuildExceptionDetails
	CREATE FUNCTION Main() RETURNS BOOLEAN
	BEGIN
		CALL BuildErrorMsg();
		RETURN FALSE;
	END;
	CREATE PROCEDURE BuildErrorMsg() BEGIN
		DECLARE rc BOOLEAN FALSE;
		CALL initLog4j(LOG_CONFIG_PATH) INTO rc;
		IF ( rc = FALSE ) THEN
			SET Environment.Variables.Log4j.ErrorMsg = LOG4J_INIT_ERROR_MSG;
		END IF;
		DECLARE excpRef REFERENCE TO InputRoot.XMLNSC.ExceptionDetails;
		DECLARE outRefer REFERENCE TO OutputRoot;
		DECLARE encodeRef REFERENCE TO InputRoot.Properties.Encoding;
		DECLARE ccidRef REFERENCE TO InputRoot.Properties.CodedCharSetId;
		DECLARE dbLoggingTime TIMESTAMP CURRENT_TIME;
		DECLARE dbLoggingDate TIMESTAMP CURRENT_TIMESTAMP;
		DECLARE domainName CHARACTER FIELDNAME(InputBody);
		DECLARE inRef REFERENCE TO InputRoot.XMLNSC;
		CREATE LASTCHILD OF OutputRoot DOMAIN 'XMLNSC';
		CREATE LASTCHILD OF OutputRoot.XMLNSC NAME 'HTTP_REQROUTER';
		DECLARE outRef REFERENCE TO OutputRoot.XMLNSC.*;
		CALL BuildExceptionDetails(excpRef,outRef,'HTTP_REQROUTER');
		SET Environment.Variables.UserDefinedErrorCodes = OutputRoot.XMLNSC;
		SET Environment.MQRFH2.usr.Id = CAST(COALESCE(InputLocalEnvironment.Destination.HTTP.RequestIdentifier,Environment.MQRFH2.RequestIdentifier,'') AS CHARACTER);
		DECLARE domainDataRef REFERENCE TO OutputRoot.XMLNSC;
		DECLARE exe_Desc CHARACTER getPayLoad(domainName,domainDataRef,encodeRef,ccidRef);
		CALL writeToLogFile(MessageFlowLabel, 'ErrorLogger', 'ERROR','..............Start Logging Application Related Exception ...........') INTO rc;
		CALL writeToLogFile(MessageFlowLabel, 'ErrorLogger', 'ERROR','Application Built Exception:'||exe_Desc) INTO rc;
		SET OutputLocalEnvironment.Destination.MQ.DestinationData[1].queueName = EXCEPTION_Q;
		PROPAGATE TO TERMINAL 'out';
		------------Error Logging in DB----------
		CALL Error_DBLogging(Environment.MQRFH2.usr.Id,Environment.Variables.reqMsg,'Application Error',ApplicationLabel,BrokerName,exe_Desc,Environment.MQRFH2.usr.dbLogTime,Environment.MQRFH2.usr.dbLogDate,'',CAST(excpRef.excpNumber AS CHARACTER),Environment.Variables.UserDefinedErrorCodes.HTTP_REQROUTER.ErrorCode,outRefer);
		CALL writeToLogFile(MessageFlowLabel, 'ErrorLogger', 'ERROR','Exception Created:'||exe_Desc) INTO rc;
		SET OutputLocalEnvironment.Destination.MQ.DestinationData[1].queueName = ERR_AUDIT_Q;
		PROPAGATE TO TERMINAL 'out';
		----------------------------------
		CREATE LASTCHILD OF OutputRoot DOMAIN 'JSON';
		CREATE LASTCHILD OF OutputRoot.JSON NAME 'Data';
		DECLARE outJsonRef REFERENCE TO OutputRoot.JSON.Data;
		SET outJsonRef.statusCode = '000';
		SET outJsonRef.message = 'FAILURE';
		SET outJsonRef.responseBody.source = 'ESB';
		SET outJsonRef.responseBody.applicationName = FIELDNAME(Environment.Variables.UserDefinedErrorCodes.HTTP_REQROUTER);
		SET outJsonRef.responseBody.applicationErrorCode = Environment.Variables.UserDefinedErrorCodes.HTTP_REQROUTER.ErrorCode;
		SET outJsonRef.responseBody.applicationErrorType = Environment.Variables.UserDefinedErrorCodes.HTTP_REQROUTER.ErrorType;
		SET OutputLocalEnvironment.Destination.HTTP.RequestIdentifier = CAST(Environment.MQRFH2.RequestIdentifier AS BLOB);
		IF IsLogRequired LIKE 'Y' THEN
			CALL writeToLogFile(MessageFlowLabel, 'ErrorLogger', 'ERROR','Response To Frond End System in case of Failure:'||getPayLoad(FIELDNAME(OutputRoot.JSON),outJsonRef,encodeRef,ccidRef)) INTO rc;
			CALL writeToLogFile(MessageFlowLabel, 'ErrorLogger', 'ERROR','End of Logging Application Related Exception') INTO rc;
		END IF;
		PROPAGATE TO TERMINAL 'out1';
		----------------------------------
	END;
END MODULE;

CREATE COMPUTE MODULE HttpResponseRouterFlow_BuildExceptionDetails
	CREATE FUNCTION Main() RETURNS BOOLEAN
	BEGIN
		CALL BuildErrorMsg();
		RETURN FALSE;
	END;

	CREATE PROCEDURE BuildErrorMsg() BEGIN
		DECLARE rc BOOLEAN FALSE;
		CALL initLog4j(LOG_CONFIG_PATH) INTO rc;
		IF ( rc = FALSE ) THEN
			SET Environment.Variables.Log4j.ErrorMsg = LOG4J_INIT_ERROR_MSG;
		END IF;
		DECLARE excpRef REFERENCE TO InputRoot.XMLNSC.ExceptionDetails;
		DECLARE outRefer REFERENCE TO OutputRoot;
		DECLARE encodeRef REFERENCE TO InputRoot.Properties.Encoding;
		DECLARE ccidRef REFERENCE TO InputRoot.Properties.CodedCharSetId;
		DECLARE dbLoggingTime TIMESTAMP CURRENT_TIME;
		DECLARE dbLoggingDate TIMESTAMP CURRENT_TIMESTAMP;
		DECLARE domainName CHARACTER FIELDNAME(InputBody);
		DECLARE inRef REFERENCE TO InputRoot.XMLNSC;
		CREATE LASTCHILD OF OutputRoot DOMAIN 'XMLNSC';
		CREATE LASTCHILD OF OutputRoot.XMLNSC NAME 'HTTP_RESROUTER';
		DECLARE outRef REFERENCE TO OutputRoot.XMLNSC.*;
		CALL BuildExceptionDetails(excpRef,outRef,'HTTP_RESROUTER');
		SET Environment.Variables.UserDefinedErrorCodes = OutputRoot.XMLNSC;
		DECLARE domainDataRef REFERENCE TO OutputRoot.XMLNSC;
		DECLARE exe_Desc CHARACTER getPayLoad(domainName,domainDataRef,encodeRef,ccidRef);
		SET Environment.MQRFH2.usr.Id = CAST(Environment.MQRFH2.RequestIdentifier AS CHARACTER);
		CALL writeToLogFile(MessageFlowLabel, 'ErrorLogger', 'DEBUG','..............Logging Exception ...........') INTO rc;
		CALL writeToLogFile(MessageFlowLabel, 'ErrorLogger', 'ERROR','Application Built Exception:'||getPayLoad(domainName,domainDataRef,encodeRef,ccidRef)) INTO rc;
		SET OutputLocalEnvironment.Destination.HTTP.RequestIdentifier = CAST(Environment.MQRFH2.RequestIdentifier AS BLOB);
		SET OutputLocalEnvironment.Destination.MQ.DestinationData[1].queueName = EXCEPTION_Q;
		PROPAGATE TO TERMINAL 'out';
		------------Error Logging in DB----------
		CALL Error_DBLogging(Environment.MQRFH2.usr.Id,Environment.Variables.reqMsg,'Application Error',ApplicationLabel,BrokerName,exe_Desc,CAST(dbLoggingTime AS CHARACTER FORMAT 'HHmmss'),CAST(dbLoggingDate AS CHARACTER FORMAT 'yyyyMMdd'),'',CAST(excpRef.excpNumber AS CHARACTER),Environment.Variables.UserDefinedErrorCodes.HTTP_RESROUTER.ErrorCode,outRefer);
		CALL writeToLogFile(MessageFlowLabel, 'ErrorLogger', 'ERROR','Exception Created:'||getPayLoad(domainName,domainDataRef,encodeRef,ccidRef)) INTO rc;
		SET OutputLocalEnvironment.Destination.MQ.DestinationData[1].queueName = ERR_AUDIT_Q;
		PROPAGATE TO TERMINAL 'out';
		----------------------------------
		CREATE LASTCHILD OF OutputRoot DOMAIN 'JSON';
		CREATE LASTCHILD OF OutputRoot.JSON NAME 'Data';
		DECLARE outJsonRef REFERENCE TO OutputRoot.JSON.Data;
		SET outJsonRef.statusCode = '000';
		SET outJsonRef.message = 'FAILURE';
		SET outJsonRef.responseBody.source = 'ESB';
		SET outJsonRef.responseBody.applicationName = FIELDNAME(Environment.Variables.UserDefinedErrorCodes.HTTP_RESROUTER);
		SET outJsonRef.responseBody.applicationErrorCode = Environment.Variables.UserDefinedErrorCodes.HTTP_RESROUTER.ErrorCode;
		SET outJsonRef.responseBody.applicationErrorType = Environment.Variables.UserDefinedErrorCodes.HTTP_RESROUTER.ErrorType;
		SET OutputLocalEnvironment.Destination.HTTP.RequestIdentifier = CAST(Environment.MQRFH2.RequestIdentifier AS BLOB);
		IF IsLogRequired LIKE 'Y' THEN
			CALL writeToLogFile(MessageFlowLabel, 'ErrorLogger', 'ERROR','Response To Frond End System in case of Failure:'||getPayLoad(FIELDNAME(OutputRoot.JSON),outJsonRef,encodeRef,ccidRef)) INTO rc;
			CALL writeToLogFile(MessageFlowLabel, 'ErrorLogger', 'ERROR','End of Logging Application Related Exception') INTO rc;
		END IF;
		PROPAGATE TO TERMINAL 'out1';
		----------------------------------
	END;
END MODULE;