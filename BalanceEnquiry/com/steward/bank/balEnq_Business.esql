

BROKER SCHEMA com.steward.bank

--PATH com.steward.log4j;
DECLARE Config_File EXTERNAL CHARACTER '';
DECLARE IsLogRequired EXTERNAL CHARACTER '';
DECLARE SERVER_IP EXTERNAL CHARACTER '';

CREATE FILTER MODULE checkPayload
	CREATE FUNCTION Main() RETURNS BOOLEAN
	BEGIN
		--DECLARE rc BOOLEAN;
		--CALL initLog (Config_File) INTO rc;
		--IF IsLogRequired = 'Y' THEN
		--CALL writerToLogFile (MessageFlowLabel,'Log','INFO','LOG :'|| CAST(CURRENT_TIMESTAMP AS CHARACTER)||CAST(ASBITSTREAM(Root.XMLNSC CCSID 1208) AS CHARACTER CCSID 1208)) INTO rc;
		--RETURN TRUE;
		--ELSE
		--RETURN FALSE;
		--END IF;
		DECLARE payload CHARACTER CAST(Root.BLOB.BLOB AS CHARACTER CCSID Root.Properties.CodedCharSetId ENCODING Root.Properties.Encoding);
		SET Environment.SERVERIP = SERVER_IP;
		SET Environment.BROKERNAME = BrokerName;
		SET Environment.EGNAME = ExecutionGroupLabel;
		SET Environment.CREATEDBY = MessageFlowLabel;
		SET Environment.MESSAGETIME = CURRENT_TIMESTAMP;
		SET Environment.PAYLOADTIME_REQUEST = CURRENT_TIMESTAMP;
		SET Environment.PAYLOAD_REQUEST = payload;

		IF STARTSWITH(payload, '{') THEN
			RETURN TRUE;
		ELSE
			RETURN FALSE;
		END IF;
	END;
END MODULE;



CREATE COMPUTE MODULE routeReq
	CREATE FUNCTION Main() RETURNS BOOLEAN
	BEGIN
		-- CALL CopyMessageHeaders();
		-- CALL CopyEntireMessage();
		IF EXISTS(InputRoot.DFDL[]) = TRUE THEN
			CREATE LASTCHILD OF OutputRoot DOMAIN 'DFDL';
			CREATE LASTCHILD OF OutputRoot.DFDL NAME 'ISO8583_1987';
			DECLARE outRef REFERENCE TO OutputRoot.DFDL.ISO8583_1987;

			CALL ConstructT24_Req(InputRoot,outRef);
		ELSEIF EXISTS(InputRoot.JSON[]) = TRUE THEN
			CREATE LASTCHILD OF OutputRoot DOMAIN 'DFDL';
			CREATE LASTCHILD OF OutputRoot.DFDL NAME 'ISO8583_1987_Unpacked';

			DECLARE teminosOutRef REFERENCE TO OutputRoot.DFDL.ISO8583_1987_Unpacked;
			CALL ConstructPostilion_Req(InputRoot,teminosOutRef);
		ELSE

		END IF;
		SET Environment.PAYLOADTP_REQUEST = 'LOG'|| CAST(InputRoot.DFDL.ISO8583_1987 AS CHARACTER CCSID InputRoot.Properties.CodedCharSetId ENCODING InputRoot.Properties.Encoding);
		SET Environment.PAYLOADTPTIME_REQUEST = CURRENT_TIMESTAMP;

		RETURN TRUE;
	END;

	CREATE PROCEDURE CopyMessageHeaders() BEGIN
		DECLARE I INTEGER 1;
		DECLARE J INTEGER;
		SET J = CARDINALITY(InputRoot.*[]);
		WHILE I < J DO
			SET OutputRoot.*[I] = InputRoot.*[I];
			SET I = I + 1;
		END WHILE;
	END;

	CREATE PROCEDURE ConstructT24_Req(IN InputRoot REFERENCE,INOUT outRef REFERENCE) BEGIN
		SET outRef = InputRoot.DFDL.ISO8583_1987;
	END;	
	


	CREATE PROCEDURE ConstructPostilion_Req(IN InputRoot REFERENCE,INOUT outRef REFERENCE) BEGIN
DECLARE IsoType CHARACTER FIELDNAME(outRef);
		SET outRef.TCPHeader = '02D9';
		SET outRef.MTI_Version = '0';
		SET outRef.MTI_MessageClass = '2';
		SET outRef.MTI_MessageFunction = '0';
		SET outRef.MTI_MessageOrigin = '0';
		SET outRef.PrimaryAccountNumber_002 = '5021951320001173';
		SET outRef.ProcessingCode_003 = '312000';
		SET outRef.AmountTransaction_004 = '0';
		SET outRef.AmountSettlement_005 = '0';
		SET outRef.TransmissionDatetime_007 = CAST('0305064626' AS TIMESTAMP FORMAT 'MMddHHmmss');
		SET outRef.ConversionRateSettlement_009 = '00000000';
		SET outRef.SystemsTraceAuditNumber_011 = '445355';
		SET outRef.TimeLocalTransaction_012 = '08:46:26.000000+00:00';
		SET outRef.DateLocalTransaction_013 = CAST('0305' AS TIMESTAMP FORMAT 'MMdd');
		SET outRef.DateExpiration_014 = CAST('2309' AS TIMESTAMP FORMAT 'yyMM');
		SET outRef.DateSettlement_015 = CAST('0306' AS TIMESTAMP FORMAT 'MMdd');
		SET outRef.DateConversion_016 = CAST('0305' AS TIMESTAMP FORMAT 'MMdd');
		SET outRef.MerchantType_018 = '5411';
		SET outRef.PointOfServiceEntryMode_022 = '051';
		SET outRef.CardSequenceNumber_023 = '001';
		SET outRef.PointOfServiceConditionCode_025 = '00';
		SET outRef.AmountTransactionFee_028 = 'C00000000';
		SET outRef.AmountSettlementFee_029 = 'C00000000';
		SET outRef.AmountTransactionProcessingFee_030 = 'C00000000';
		SET outRef.AmountSettlementProcessingFee_031 = 'C00000000';
		SET outRef.AcquiringInstitutionIdentificationCode_032 = '502195';
		SET outRef.Track2Data_035 = '5021951320001173=2309226';
		SET outRef.RetrievalReferenceNumber_037 = '006508000449';
		SET outRef.AuthorizationIdentificationResponse_038 = '084804';
		SET outRef.ResponseCode_039 = '00';
		SET outRef.ServiceRestrictionCode_040 = '226';
		SET outRef.CardAcceptorTerminalIdentification_041 = 'SBB09484';
		SET outRef.CardAcceptorIdentificationCode_042 = '9999900076ECOMD';
		SET outRef.CardAcceptorNameLocation_043 = 'Econet Mt Darwin CommutMt Darwin&#32;&#32;&#32;&#32;25ZW';
		SET outRef.CurrencyCodeTransaction_049 = '840';
		SET outRef.CurrencyCodeSettlement_050 = '932';
		SET outRef.ReservedISO_056 = '1003';
		SET outRef.ReservedNational_059 = '0695974333';
		SET outRef.ReplacementAmounts_095 = '000000000000000000000000C00000000C00000000';
		SET outRef.ReceivingInstitutionIdentificationCode_100 = '727272';
		SET outRef.AccountIdentification1_102 = '1036231544';
		SET outRef.ReservedPrivate_123 = '51010151014C101';
		SET outRef."RoutingInformationPostilionPrivate_127.3" = '202020TermAppISO&#32;&#32;StewardBPOS 000449445355SBZDeb';
		SET outRef."POSDataPostilionPrivate_127.4" = 'itGrp SBB0948400044100';
		SET outRef."CheckDataPostilionPrivate_127.7" = '999 44002';
		SET outRef."AddressVerificationResultPostilionPrivate_127.16" = '0';
		SET outRef."BankDetailsPostilionPrivate_127.19" = '0716&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;02267C1E4F7C0000000';
		SET outRef."OriginatorAuthorizerDatePostilionPrivate_127.20" = '00000000';
		SET outRef."ApplicationIdentifierPostilionPrivate_127.25.4" = '0004107FCEDAE7C432';
		SET outRef."ApplicationTransactionCounterPostilionPrivate_127.25.6" = 'DF10';
		SET outRef."CardAuthReliabilityIndicatiorPostilionPrivate_127.25.9" = '8';
		SET outRef."ChipConditionCodePostilionPrivate_127.25.11" = '0';
		SET outRef."SecureData3DResultPostilionPrivate_127.30" = '0';
		SET outRef."ExtendedResponseCodePostilionPrivate_127.37" = '2000';
		SET outRef."AdditionalPOSDataCodePostilionPrivate_127.38" = '000000000000020320300640FA501A20000000000000000000000000F010000000000000000000000000000E0F0C8716228';
		CALL updateMsgWithHexBitMap(outRef); 
		--CALL updateMsgWithAsciiBitMap(outRef); 
		CALL updateMsgWithHexBitMapPostilion(outRef);
	END;
END MODULE;



CREATE COMPUTE MODULE banalceEnquiry_Res
	CREATE FUNCTION Main() RETURNS BOOLEAN
	BEGIN
		-- CALL CopyMessageHeaders();
		-- CALL CopyEntireMessage();

		DECLARE inRef REFERENCE TO InputRoot.DFDL.*;
		CALL ConstructBE_Res(inRef,OutputRoot);

		RETURN TRUE;
	END;

	CREATE PROCEDURE CopyMessageHeaders() BEGIN
		DECLARE I INTEGER 1;
		DECLARE J INTEGER;
		SET J = CARDINALITY(InputRoot.*[]);
		WHILE I < J DO
			SET OutputRoot.*[I] = InputRoot.*[I];
			SET I = I + 1;
		END WHILE;
	END;

	CREATE PROCEDURE ConstructBE_Res(IN inRef REFERENCE, INOUT OutputRoot REFERENCE) BEGIN
		DECLARE primaryBitmap REFERENCE TO inRef.PrimaryBitmap;
		DECLARE secondaryBitmap REFERENCE TO inRef.SecondaryBitmap;
		SET Environment.MSG.Properties = InputRoot.Properties;
		SET Environment.MSG.MQMD = InputRoot.MQMD;

		SET Environment.InputRequest = InputRoot.DFDL.*;
		SET Environment.version = InputRoot.DFDL.*.MTI_Version;

		DECLARE outPayLoadRef REFERENCE TO OutputRoot.DFDL.ISO8583_1987;
		-- Assigning MessageType Properties with Required ISO message
		SET OutputRoot.Properties.MessageType = '{}:ISO8583_1987';
		-- Creating Domain and ISO type
		CREATE LASTCHILD OF OutputRoot AS outPayLoadRef DOMAIN 'DFDL';
		CREATE LASTCHILD OF outPayLoadRef AS outPayLoadRef NAME 'ISO8583_1987';		
		-- Adding MTI header
		SET outPayLoadRef.MTI_Version = '0';
		SET outPayLoadRef.MTI_MessageClass = '2';
		SET outPayLoadRef.MTI_MessageFunction = '1';
		SET outPayLoadRef.MTI_MessageOrigin = '0';
		-- method for initialising Field list
		-- CALL GenNPCIReqMsgWithXML();
		--CALL updateMsgWithHexBitMap(outPayLoadRef);
		CALL updateMsgWithAsciiBitMap(outPayLoadRef);

		SET Environment.PAYLOADTIME_RESPONSE = CAST(OutputRoot.DFDL.ISO8583_1987 AS CHARACTER CCSID InputRoot.Properties.CodedCharSetId ENCODING InputRoot.Properties.Encoding);
		SET Environment.PAYLOAD_RESPONSE = CURRENT_TIMESTAMP;
		-------------
		SET Environment.STATUS = 'SUCCESS' ;
		--SET Environment.ERROR_CODE = inref.ERROR_CODE ;
		--SET Environment.ERROR_DESC = inref.ERROR_DESC ;
		--SET Environment.ERROR_TYPE = inref.ERROR_TYPE;
		SET Environment.RESPONSE_CODE = '00';
	END;
END MODULE;


CREATE COMPUTE MODULE T24Req
	CREATE FUNCTION Main() RETURNS BOOLEAN
	BEGIN
		-- CALL CopyMessageHeaders();
		CALL CopyEntireMessage();
		RETURN TRUE;
	END;

	CREATE PROCEDURE CopyMessageHeaders() BEGIN
		DECLARE I INTEGER 1;
		DECLARE J INTEGER;
		SET J = CARDINALITY(InputRoot.*[]);
		WHILE I < J DO
			SET OutputRoot.*[I] = InputRoot.*[I];
			SET I = I + 1;
		END WHILE;
	END;

	CREATE PROCEDURE CopyEntireMessage() BEGIN
		SET OutputRoot = InputRoot;
	END;
END MODULE;
---Construct Error Response
CREATE COMPUTE MODULE construct_ErrorRes
	CREATE FUNCTION Main() RETURNS BOOLEAN
	BEGIN
		-- CALL CopyMessageHeaders();
		-- CALL CopyEntireMessage();

		CALL ConstructError_Res();
		--IF excpRef.excpType = ''

		RETURN TRUE;
	END;

	CREATE PROCEDURE CopyMessageHeaders() BEGIN
		DECLARE I INTEGER 1;
		DECLARE J INTEGER;
		SET J = CARDINALITY(InputRoot.*[]);
		WHILE I < J DO
			SET OutputRoot.*[I] = InputRoot.*[I];
			SET I = I + 1;
		END WHILE;
	END;

	CREATE PROCEDURE ConstructError_Res() BEGIN
		DECLARE excpRef REFERENCE TO InputRoot.XMLNSC.ExceptionDetails;
		CREATE LASTCHILD OF OutputRoot DOMAIN 'XMLNSC';
		CREATE LASTCHILD OF OutputRoot.XMLNSC NAME 'BalanceEnquiry';
		DECLARE outRef REFERENCE TO OutputRoot.XMLNSC.*;
		SET outRef.excpType = FIELDNAME(excpRef);
		SET outRef.excpNumber = excpRef.Number;
		SET outRef.excpLable = excpRef.Label;
		SET outRef.excpText = excpRef.Text;
		IF excpRef.excpType = 'FatalException' THEN

			SET outRef.Status = 'FAILURE';
			SET outRef.ErrorCode = 'BALENQ_001';
			SET outRef.ErrorType = excpRef.excpType;
			SET outRef.Description = 'Fatal exception at'||CAST(excpRef.excpLable AS CHARACTER);

		ELSEIF excpRef.excpType = 'RecoverableException' THEN

			SET outRef.Status = 'FAILURE';
			SET outRef.ErrorCode = 'BALENQ_002';
			SET outRef.ErrorType = excpRef.excpType;
			SET outRef.Description = 'Recoverable Exception at'||CAST(excpRef.excpLable AS CHARACTER);

		ELSEIF excpRef.excpType = 'ConfigurationException' THEN

			SET outRef.Status = 'FAILURE';
			SET outRef.ErrorCode = 'BALENQ_003';
			SET outRef.ErrorType = excpRef.excpType;
			SET outRef.Description = 'Configuration Exception at'||CAST(excpRef.excpLable AS CHARACTER);

		ELSEIF excpRef.excpType = 'SecurityException' THEN

			SET outRef.Status = 'FAILURE';
			SET outRef.ErrorCode = 'BALENQ_004';
			SET outRef.ErrorType = excpRef.excpType;
			SET outRef.Description = 'Security Exception at'||CAST(excpRef.excpLable AS CHARACTER);

		ELSEIF excpRef.excpType = 'ParserException' THEN

			SET outRef.Status = 'FAILURE';
			SET outRef.ErrorCode = 'BALENQ_005';
			SET outRef.ErrorType = excpRef.excpType;
			SET outRef.Description = 'Parser Exceptionat'||CAST(excpRef.excpLable AS CHARACTER);

		ELSEIF excpRef.excpType = 'ConversionException' THEN

			SET outRef.Status = 'FAILURE';
			SET outRef.ErrorCode = 'BALENQ_006';
			SET outRef.ErrorType = excpRef.excpType;
			SET outRef.Description = 'Conversion Exception at'||CAST(excpRef.excpLable AS CHARACTER);

		ELSEIF excpRef.excpType = 'DatabaseException' THEN

			SET outRef.Status = 'FAILURE';
			SET outRef.ErrorCode = 'BALENQ_007';
			SET outRef.ErrorType = excpRef.excpType;
			SET outRef.Description = 'Database Exception at'||CAST(excpRef.excpLable AS CHARACTER);

		ELSEIF excpRef.excpType = 'UserException' THEN

			SET outRef.Status = 'FAILURE';
			SET outRef.ErrorCode = 'BALENQ_008';
			SET outRef.ErrorType = excpRef.excpType;
			SET outRef.Description = 'User Exception at'||CAST(excpRef.excpLable AS CHARACTER);

		ELSEIF excpRef.excpType = 'CastException' THEN

			SET outRef.Status = 'FAILURE';
			SET outRef.ErrorCode = 'BALENQ_009';
			SET outRef.ErrorType = excpRef.excpType;
			SET outRef.Description = 'Cast Exception at'||CAST(excpRef.excpLable AS CHARACTER);

		ELSEIF excpRef.excpType = 'MessageException' THEN

			SET outRef.Status = 'FAILURE';
			SET outRef.ErrorCode = 'BALENQ_010';
			SET outRef.ErrorType = excpRef.excpType;
			SET outRef.Description = 'Message Exception at'||CAST(excpRef.excpLable AS CHARACTER);

		ELSEIF excpRef.excpType = 'SqlException' THEN

			SET outRef.Status = 'FAILURE';
			SET outRef.ErrorCode = 'BALENQ_011';
			SET outRef.ErrorType = excpRef.excpType;
			SET outRef.Description = 'Sql Exception at'||CAST(excpRef.excpLable AS CHARACTER);

		ELSEIF excpRef.excpType = 'SocketException' THEN

			SET outRef.Status = 'FAILURE';
			SET outRef.ErrorCode = 'BALENQ_012';
			SET outRef.ErrorType = excpRef.excpType;
			SET outRef.Description = 'Socket Exception at'||CAST(excpRef.excpLable AS CHARACTER);

		ELSEIF excpRef.excpType = 'SocketTimeoutException' THEN

			SET outRef.Status = 'FAILURE';
			SET outRef.ErrorCode = 'BALENQ_013';
			SET outRef.ErrorType = excpRef.excpType;
			SET outRef.Description = 'Socket Timeout Exception at'||CAST(excpRef.excpLable AS CHARACTER);

		ELSEIF excpRef.excpType = 'UnknownException' THEN

			SET outRef.Status = 'FAILURE';
			SET outRef.ErrorCode = 'BALENQ_014';
			SET outRef.ErrorType = excpRef.excpType;
			SET outRef.Description = 'Unknown Exception at'||CAST(excpRef.excpLable AS CHARACTER);


		ELSE

			SET outRef.Status = 'FAILURE';
			SET outRef.ErrorCode = 'BALENQ_015';
			SET outRef.ErrorType = excpRef.excpType;
			SET outRef.Description = 'Exception at'||CAST(excpRef.excpLable AS CHARACTER);

		END IF;
	END;
END MODULE;