/*
Author:Rathod Veerender
Version:0.0.1
Date of Creation:30-03-2020
Date of Modification:14-04-2020,15-04-2020,16-04-2020,17-04-2020 
Description: Generate a XML message which provide description for Exception which occured in flow and 
			generate error in iso format to respond back to front end and also handled retry mechanism.
 			
*/
BROKER SCHEMA com.stewardbank.co.zw.common.exceptionhandler
PATH com.stewardbank.co.zw.common.esql;
DECLARE LOG_CONFIG_PATH EXTERNAL CHARACTER '';
DECLARE IS_ERROR_RESPONSE_REQUIRED EXTERNAL CHARACTER '';
DECLARE INIT_LOG4J_ERROR EXTERNAL CHARACTER '';
DECLARE EXCEPTIONQ EXTERNAL CHARACTER '';
DECLARE MAX_RETRY_COUNT EXTERNAL INTEGER 0;
DECLARE rc BOOLEAN FALSE;
CREATE COMPUTE MODULE ExceptionHandling
	CREATE FUNCTION Main() RETURNS BOOLEAN
	BEGIN
		CALL CopyMessageHeaders();
		--set input properties in environment
		SET Environment.Variables.Properties = InputRoot.Properties;
		
		/* ============================= THIS IS FOR DBLOGGING ***** I'M CASTING  INPUT.DFDL DATA INTO CHARACTER ========================= */
		DECLARE tcpipDetails REFERENCE TO InputLocalEnvironment.TCPIP.Input.ConnectionDetails;
		DECLARE timeLocalTransaction CHARACTER InputRoot.DFDL.ISO8583_1987.TimeLocalTransaction_012;
		DECLARE dateLocalTransaction CHARACTER InputRoot.DFDL.ISO8583_1987.DateLocalTransaction_013;
		DECLARE retrievalReferenceNumber CHARACTER InputRoot.DFDL.ISO8583_1987.RetrievalReferenceNumber_037;
		SET Environment.reqMsg= CAST(ASBITSTREAM(InputRoot.DFDL ENCODING InputRoot.Properties.Encoding CCSID InputRoot.Properties.CodedCharSetId SET '{ISO8583_Lib}' TYPE '{}:ISO8583_1987') AS CHARACTER);
		SET OutputRoot.MQRFH2.tcpId.Id=CAST(InputLocalEnvironment.TCPIP.Input.ConnectionDetails.Id AS CHARACTER);
--SET Environment.tcpip.Id=CAST(InputLocalEnvironment.TCPIP.Input.ConnectionDetails.Id AS CHARACTER);
		SET Environment.timeLocalTransaction=timeLocalTransaction;
		SET Environment.dateLocalTransaction=dateLocalTransaction;
		SET Environment.retrievalReferenceNumber=retrievalReferenceNumber;
--		
		/*  ==================================== DB LOGGING PROPERTIES END ===================================== */
		
		CALL initLog4j(LOG_CONFIG_PATH) INTO rc;
		IF ( rc = FALSE ) THEN
			SET Environment.Variables.Log4j.ErrorMsg = INIT_LOG4J_ERROR;
			CALL writeToLogFile(MessageFlowLabel, 'ErrorLogger', 'ERROR',INIT_LOG4J_ERROR) INTO rc;		
		END IF;
		CALL writeToLogFile(MessageFlowLabel, 'ErrorLogger', 'ERROR','..............start logging Exception...........') INTO rc;
		CREATE LASTCHILD Of OutputRoot DOMAIN 'XMLNSC';
		CREATE LASTCHILD Of OutputRoot.XMLNSC NAME 'ExceptionDetails';  
		DECLARE outRef REFERENCE TO OutputRoot.XMLNSC.ExceptionDetails;
		DECLARE excpRef REFERENCE TO InputExceptionList.*[1];
		DECLARE insertRef REFERENCE TO InputExceptionList.*[1];
		--get exception in xml format
		CALL getExceptionDesc(excpRef,insertRef,outRef);
		
		SET Environment.Variables.ExceptionData = OutputRoot.XMLNSC.ExceptionDetails;
		DECLARE exceptionTxt CHARACTER Environment.Variables.ExceptionData.excpText;
		DECLARE exceptiondesc,inputChar,logdata CHARACTER;
		DECLARE ccsid INTEGER;
		DECLARE domainFldName CHARACTER FIELDNAME(InputBody);
		IF CONTAINS(exceptionTxt,'ParserException') THEN
			SET inputChar='unable to parse the data';
		ELSE
			CASE
	
				WHEN domainFldName='XMLNSC' AND EXISTS(InputRoot.XMLNSC.*[]) THEN
					SET inputChar=COALESCE(inputChar,0);
					SET inputChar=CAST(ASBITSTREAM(InputRoot.XMLNSC) AS CHARACTER CCSID InputRoot.Properties.CodedCharSetId ENCODING InputRoot.Properties.Encoding);
				WHEN domainFldName='SOAP' AND EXISTS(InputRoot.SOAP.*[]) THEN
					SET inputChar=CAST(ASBITSTREAM(InputRoot.SOAP) AS CHARACTER CCSID InputRoot.Properties.CodedCharSetId ENCODING InputRoot.Properties.Encoding);
				WHEN domainFldName='BLOB' AND EXISTS(InputRoot.BLOB.*[]) THEN
					SET inputChar=CAST(ASBITSTREAM(InputRoot.BLOB) AS CHARACTER CCSID InputRoot.Properties.CodedCharSetId ENCODING InputRoot.Properties.Encoding);
				WHEN domainFldName='DFDL' AND EXISTS(InputRoot.DFDL.*[]) THEN
					SET Environment.Variables.DFDL = InputRoot.DFDL;
					SET inputChar=CAST(ASBITSTREAM(InputRoot CCSID InputRoot.Properties.CodedCharSetId ) AS CHARACTER CCSID InputRoot.Properties.CodedCharSetId );
				WHEN (domainFldName='JSON' AND EXISTS(InputRoot.JSON.*[])) THEN
					SET inputChar=CAST(ASBITSTREAM(InputRoot.JSON) AS CHARACTER CCSID InputRoot.Properties.CodedCharSetId ENCODING InputRoot.Properties.Encoding);
			END CASE;
		END IF;			
		IF inputChar is not null THEN
		ELSE
			SET inputChar=COALESCE(inputChar,'emptydata or unable to parse the data');
		END IF;	
		DECLARE CR CHARACTER CAST(CAST('X''0A''' AS BLOB) AS CHARACTER CCSID InputRoot.Properties.CodedCharSetId);
		SET logdata = exceptionTxt||CR||'INPUT_ORIGINAL_MESSAGE:START'||CR||inputChar||CR||'INPUT_ORIGINAL_MESSAGE:STOP' ;
		CALL writeToLogFile(MessageFlowLabel,'ErrorLogger','ERROR',exceptionTxt) into rc;
		CALL writeToLogFile(MessageFlowLabel,'ErrorLogger','ERROR',logdata) into rc;
		--start editing(If T24 is down or unavailable send error response to front end in ISO with ResponseCode(06))
		IF EXISTS(InputExceptionList.*[]) AND  
			(CONTAINS(exceptionTxt,'Connection refused') OR
			CONTAINS(exceptionTxt,'Connection Dead') OR 
			CONTAINS(exceptionTxt,'your session has been killed') OR
			CONTAINS(exceptionTxt,'Unexpected Network Error'))THEN
			CALL writeToLogFile(MessageFlowLabel, 'ErrorLogger', 'ERROR','Connection refused or Connection Dead or your session has been killed or Unexpected Network Error') INTO rc;
			IF Environment.Variables.Counter IS NULL THEN 
				SET Environment.Variables.Counter = 1; 
			END IF;
			IF Environment.Variables.Counter <= MAX_RETRY_COUNT THEN
				SET OutputRoot = null;
				CALL CopyMessageHeaders();
				SET OutputRoot = InputRoot;
				SET Environment.Variables.Counter = Environment.Variables.Counter + 1;
				CALL writeToLogFile(MessageFlowLabel, 'ErrorLogger', 'ERROR','tcp connection exception retry count:'||CAST(Environment.Variables.Counter AS CHARACTER)) INTO rc;
				RETURN TRUE;
			ELSE
				CALL writeToLogFile(MessageFlowLabel, 'ErrorLogger', 'ERROR','tcp connection exception retry count reached send response') INTO rc;
				SET OutputRoot = null;
				CALL CopyMessageHeaders();
				CALL revertBackToSystem();
				CALL LogException();
				CALL writeToLogFile(MessageFlowLabel, 'ErrorLogger', 'ERROR','..............end of logging Exception...........') INTO rc;
				RETURN FALSE;
			END IF;
		ELSE
			CALL writeToLogFile(MessageFlowLabel, 'ErrorLogger', 'ERROR','..............end of logging Exception...........') INTO rc;
			RETURN TRUE;
		END IF;
	END;
	CREATE PROCEDURE LogException() BEGIN
		CALL writeToLogFile(MessageFlowLabel, 'ErrorLogger', 'ERROR','Capturing Connection refused or Connection Dead or your session has been killed or Unexpected Network Error in Exception Q') INTO rc;
		CREATE LASTCHILD Of OutputRoot DOMAIN 'XMLNSC';
		CREATE LASTCHILD Of OutputRoot.XMLNSC NAME 'ExceptionDetails';  
		SET OutputRoot.XMLNSC.ExceptionDetails = Environment.Variables.ExceptionData;
		SET OutputLocalEnvironment.Destination.MQ.DestinationData[1].queueName = EXCEPTIONQ;
		PROPAGATE TO TERMINAL 'out1';
	END;
	CREATE PROCEDURE CopyMessageHeaders() BEGIN
		DECLARE I INTEGER 1;
		DECLARE J INTEGER;
		SET J = CARDINALITY(InputRoot.*[]);
		WHILE I < J DO
			SET OutputRoot.*[I] = InputRoot.*[I];
			SET I = I + 1;
		END WHILE;
	END;
	/*
	revertBackToSystem procedure requires property,domain,responseQueue in environment
	*/
	CREATE PROCEDURE revertBackToSystem()
	BEGIN 
		CALL writeToLogFile(MessageFlowLabel, 'ErrorLogger', 'ERROR','Revert back to front end') INTO rc;
		DECLARE inRef REFERENCE TO Environment.Variables.DFDL.ISO8583_1987;
		CREATE LASTCHILD OF OutputRoot DOMAIN ('DFDL');
		DECLARE outRef REFERENCE TO OutputRoot.DFDL;
		CREATE LASTCHILD OF OutputRoot.DFDL AS outRef NAME 'ISO8583_1987';
		DECLARE mtiRes CHARACTER '';
		CALL initLog4j(LOG_CONFIG_PATH) INTO rc;			
		IF ( rc = FALSE ) THEN
			DECLARE msg CHARACTER ;
			SET Environment.Variables.Log4j.ErrorMsg = INIT_LOG4J_ERROR;
			CALL writeToLogFile(MessageFlowLabel, 'ErrorLogger', 'ERROR',INIT_LOG4J_ERROR) INTO rc;		
		END IF;
		--generate a error response in iso8583 to front end system in case of failure of t24
		CALL FieldToFieldMapping(inRef,outRef,IS_ERROR_RESPONSE_REQUIRED);
		
		CALL MTIResponse(CAST(inRef.MTI_Version AS CHARACTER),CAST(inRef.MTI_MessageClass AS CHARACTER),CAST(inRef.MTI_MessageFunction AS CHARACTER),CAST(inRef.MTI_MessageOrigin AS CHARACTER)) into mtiRes;
		SET outRef.MTI_Version=SUBSTRING(mtiRes FROM 1 FOR 1);
		SET outRef.MTI_MessageClass=SUBSTRING(mtiRes FROM 2 FOR 1);
		SET outRef.MTI_MessageFunction=SUBSTRING(mtiRes FROM 3 FOR 1); 
		SET outRef.MTI_MessageOrigin=SUBSTRING(mtiRes FROM 4 FOR 1);
		SET OutputLocalEnvironment.Destination.MQ.DestinationData[1].queueName = Environment.Variables.ResponseQ;
		CALL writeToLogFile(MessageFlowLabel, 'ErrorLogger', 'INFO','reponse queue:') INTO rc;
		CALL writeToLogFile(MessageFlowLabel, 'ErrorLogger', 'INFO',Environment.Variables.ResponseQ) INTO rc;
		CALL writeToLogFile(MessageFlowLabel, 'ErrorLogger', 'ERROR','Response To Postilion::') INTO rc;
		CALL writeToLogFile(MessageFlowLabel, 'ErrorLogger', 'ERROR',CAST(ASBITSTREAM(OutputRoot.DFDL CCSID Environment.Variables.Properties.CodedCharSetId SET '{ISO8583_Lib}' TYPE '{}:ISO8583_1987') AS CHARACTER CCSID Environment.Variables.Properties.CodedCharSetId)) INTO rc;
		CALL writeToLogFile(MessageFlowLabel, 'ErrorLogger', 'ERROR','Revert back to front end done') INTO rc;
		PROPAGATE TO TERMINAL 'out1';
	END;
	CREATE PROCEDURE getExceptionDesc(IN excpRef REFERENCE,IN insertRef REFERENCE,INOUT outRef REFERENCE)	
	BEGIN
		DECLARE messageText CHARACTER '';
		DECLARE exceptionName CHARACTER '';
		WHILE LASTMOVE(excpRef) DO
			IF excpRef.Number is not null THEN
				SET outRef.excpType = FIELDNAME(excpRef);
				SET exceptionName = FIELDNAME(excpRef);
				SET outRef.excpNumber = excpRef.Number;
				SET outRef.excpLable = excpRef.Label;
				IF stringValidation(excpRef.Text) THEN
					SET messageText = messageText||','||excpRef.Text;
				END IF;
				--- fetch description from Insert[]
				MOVE insertRef TO excpRef.Insert[>];
				WHILE LASTMOVE(insertRef) AND FIELDNAME(insertRef) = 'Insert' DO 
					IF NOT LENGTH(insertRef.Text) = 1 AND
						stringValidation(insertRef.Text)THEN
						SET messageText = messageText||','||insertRef.Text;
					END IF;
					MOVE insertRef NEXTSIBLING;
				END WHILE;
				
			--started editing(removed since we are capturing all insert field data)
			/*
			ELSE
				IF FIELDVALUE(excpRef) <> '' AND LENGTH(FIELDVALUE(excpRef)) > 15 THEN
					SET outRef.excpText = FIELDVALUE(excpRef); 
				END IF;
			*/
			--ended editing(removed since we are capturing all insert field data)
			END IF;
			move excpRef lastchild;
		END WHILE;
		SET outRef.excpText = exceptionName||''||OVERLAY(messageText PLACING ':' FROM 1 FOR 1);
	END;
	CREATE PROCEDURE stringValidation (IN text CHARACTER)
	RETURNS BOOLEAN
	BEGIN
		IF NOT CONTAINS(text, 'Node throwing exception') AND
			NOT CONTAINS(text, 'Caught exception and rethrowing') AND
			NOT CONTAINS(text, 'Error detected, rethrowing') AND
			NOT CONTAINS(text, 'Error occured in procedure') AND
			NOT LENGTH(text) = 1 THEN
			RETURN TRUE;
		ELSE
			RETURN FALSE;
		END IF;
	END;
END MODULE;
